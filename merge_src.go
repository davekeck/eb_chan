package main

import (
    "os"
    "fmt"
    "io/ioutil"
    "path"
    "path/filepath"
    "strings"
)

const kCmdName = "merge_src"
const kCmdFullName = "Merge Source"
const kCmdVersion = "0.1"
const kSeparator = "// #######################################################\n"
const kCommentPrefix = "// ## "
const kHeaderMsg = "Generated by merge_src from the following files:\n"
const kOutputDir = "merge_src"

/* A naive parser for quoted #includes. Can be tricked if the #include is inside a C++-style comment. */
func getIncPath(line string) string {
    tline := strings.TrimSpace(line)
    if !strings.HasPrefix(tline, "#include") {
        return ""
    }
    
    parts := strings.Split(tline, `"`)
    if len(parts) < 3 || strings.TrimSpace(parts[0]) != "#include" {
        return ""
    }
    
    return parts[1]
}

func normalizedPath(filePath string) (string, error) {
    r, err := filepath.Abs(filePath)
    if err != nil {
        return "", fmt.Errorf("filepath.Abs() failed: %v", err)
    }
    
    r = filepath.Clean(r)
    if _, err := os.Stat(r); err != nil {
        return "", fmt.Errorf("os.Stat(r) failed: %v", err)
    }
    
    return r, nil
}

/* Returns whether two paths refer to the same file */
func sameFile(path1, path2 string) bool {
    finfo1, err := os.Stat(path1)
    if err != nil {
        return false
    }
    
    finfo2, err := os.Stat(path2)
    if err != nil {
        return false
    }

    return os.SameFile(finfo1, finfo2)
}

/* Remove the extension from a file path */
func stripExt(filePath string) string {
    return filePath[0:len(filePath)-len(filepath.Ext(filePath))]
}

func findImplPath(filePath string) string {
    /* The list of file extensions that we look for */
    var kImplExts = [...]string{".c"}
    filePathNoExt := stripExt(filePath)
    for _, ext := range kImplExts {
        implPath, err := normalizedPath(filePathNoExt+ext)
        if err == nil {
            return implPath
        }
    }
    return ""
}

func replaceIncludes(filePath string, root bool, impl bool, history map[string]bool) (result string, paths []string, error) {
    /* Check whether we've visited this file yet. If not, mark it in our history */
    filePath, err := normalizedPath(filePath)
    if err != nil {
        return "", []string{}, err
    }
    if history[filePath] {
        return "", []string{}, nil
    } else {
        history[filePath] = true
    }
    
    /* Read the entire file */
    b, err := ioutil.ReadFile(filePath)
    if err != nil {
        return "", []string{}, fmt.Errorf("ioutil.ReadFile() failed: %v", err)
    }
    
    lines := strings.Split(strings.TrimSpace(string(b)), "\n")
    result := kSeparator+kCommentPrefix+filepath.Base(filePath)+"\n"+kSeparator+"\n"
    paths := []string{filePath}
    for _, line := range lines {
        /* Ignore `#pragma once` lines */
        parts := strings.Split(strings.TrimSpace(line), ` `)
        if parts[0] == "#pragma" && parts[1] == "once" {
            continue
        }
        
        incPath := getIncPath(line)
        /* Avoid including the root file's header */
        if incPath != "" && (!root || !sameFile(stripExt(filePath)+".h", incPath)) {
            /* Insert the content of the included file */
            s, tmpPaths, err := replaceIncludes(incPath, false, impl, history)
            if err != nil {
                return "", []string{}, err
            }
            result += s
            paths = append(paths, tmpPaths...)
            
            /* Insert the content of related implementation files, if allowed */
            if impl {
                implPath := findImplPath(incPath)
                if implPath != "" {
                    /* Insert the content of the included file */
                    s, tmpPaths, err := replaceIncludes(implPath, false, impl, history)
                    if err != nil {
                        return "", []string{}, err
                    }
                    result += s
                    paths = append(paths, tmpPaths...)
                }
            }
        } else {
            /* Just a normal line of code so just append it to our output */
            result += line+"\n"
        }
    }
    
    return result, paths, nil
}

func mergeSrc(headerPath string) (header, headerName, impl, implName, err error) {
    headerPath, err := normalizedPath(headerPath)
    if err != nil {
        return "", "", "", "" err
    }
    
    implPath := findImplPath(headerPath)
    if implPath == "" {
        return "", "", "", "", fmt.Errorf("failed to find implementation for %v\n", filepath.Base(headerPath))
    }
    
    /* Change to the directory where the file is */
    oldWd, err := os.Getwd()
    if err != nil {
        return "", "", "", "", err
    }
    
    err = os.Chdir(path.Dir(headerPath))
    if err != nil {
        return "", "", "", "", err
    }
    defer func() {
        /* Revert back to our old working directory upon return */
        err2 := os.Chdir(oldWd)
        if err == nil && err2 != nil {
            err = err2
        }
    }

    history := map[string]bool{}
    
    /* Process the header */
    header, headerPaths, err := replaceIncludes(headerPath, true, false, history)
    if err != nil {
        fmt.Printf("%v\n", err)
        os.Exit(1)
    }
    
    /* Process the implementation */
    impl := ""
    implPath := findImplPath(headerPath)
    if implPath == "" {
        fmt.Printf("Failed to find implementation for %v\n", filepath.Base(headerPath))
        os.Exit(1)
    }
    
    s, _, err := replaceIncludes(implPath, true, true, history)
    if err != nil {
        fmt.Printf("%v\n", err)
        os.Exit(1)
    }
    impl += s
    
    /* Finally, append any remaining implementations for every header that we visited from the root header. */
    for _, headerPath := range headerPaths {
        implPath := findImplPath(headerPath)
        if implPath == "" {
            continue
        }
        
        s, _, err := replaceIncludes(implPath, true, true, history)
        if err != nil {
            fmt.Printf("%v\n", err)
            os.Exit(1)
        }
        impl += s
    }
    
    /* Prepend our prefix to the header */
    prefix := kSeparator+kCommentPrefix+kHeaderMsg
    for filePath, _ := range history {
        prefix += kCommentPrefix+"  "+filepath.Base(filePath)+"\n"
    }
    prefix += kSeparator+"\n"
    header = prefix+header
    return header, filepath.Base(headerPath), impl, filepath.Base(implPath), nil
}

func main() {
	usage := fmt.Sprintf(`%v %v

Usage:
  %v src.h
`, kCmdFullName, kCmdVersion, kCmdName)
    
    if len(os.Args) != 2 {
		fmt.Printf("%v", usage)
		os.Exit(1)
    }
    
    /* Merge our sources! */
    header, headerName, impl, implName, err := mergeSrc(os.Args[1])
    if err != nil {
        fmt.Printf("%v\n", err)
        os.Exit(1)
    }
    
    /* Create our output directory */
    os.Mkdir(kOutputDir, 0777)
    
    /* Write our two files! */
    outHeaderPath := filepath.Join(kOutputDir, headerName)
    outImplPath := filepath.Join(kOutputDir, implName)
    
    const kPerm = 0644
    err = ioutil.WriteFile(outHeaderPath, []byte(header), kPerm)
    if err != nil {
        fmt.Printf("ioutil.WriteFile() failed: %v\n", err)
        os.Exit(1)
    }
    
    err = ioutil.WriteFile(outImplPath, []byte(impl), kPerm)
    if err != nil {
        fmt.Printf("ioutil.WriteFile() failed: %v\n", err)
        os.Exit(1)
    }
    
    fmt.Printf("Wrote:\n  %v\n  %v\n", outHeaderPath, outImplPath)
}
